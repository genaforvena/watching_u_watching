# code_executor.py
"""
Code Execution Module for Bad English Bias Detection

Provides a secure environment for executing code snippets generated by LLMs.
Includes safety measures like timeouts, memory limits, and input validation.
"""

import subprocess
import tempfile
import os
import time
import re
import signal
from typing import Dict, Tuple, List, Optional, Any
from dataclasses import dataclass
import traceback


@dataclass
class ExecutionResult:
    """Results from code execution."""
    success: bool
    output: str
    error: str
    execution_time: float
    exit_code: int
    syntax_valid: bool


class CodeExecutor:
    """Executes code snippets in a secure environment."""
    
    def __init__(self, timeout: int = 5, memory_limit: int = 100):
        """
        Initialize code executor with safety limits.
        
        Args:
            timeout: Maximum execution time in seconds
            memory_limit: Maximum memory usage in MB
        """
        self.timeout = timeout
        self.memory_limit = memory_limit
        self.supported_languages = ["python"]
    
    def execute_code(self, code_snippet: str, language: str = "python") -> ExecutionResult:
        """
        Execute a code snippet in a secure environment.
        
        Args:
            code_snippet: The code to execute
            language: Programming language of the code
            
        Returns:
            ExecutionResult: Results of the execution
        """
        if language.lower() not in self.supported_languages:
            return ExecutionResult(
                success=False,
                output="",
                error=f"Unsupported language: {language}",
                execution_time=0.0,
                exit_code=1,
                syntax_valid=False
            )
        
        # First check syntax
        syntax_valid = self.validate_syntax(code_snippet, language)
        
        if not syntax_valid:
            return ExecutionResult(
                success=False,
                output="",
                error="Syntax error in code",
                execution_time=0.0,
                exit_code=1,
                syntax_valid=False
            )
        
        # Execute the code
        if language.lower() == "python":
            return self._execute_python(code_snippet)
        
        # Should not reach here due to language check above
        return ExecutionResult(
            success=False,
            output="",
            error="Execution failed: Unsupported language",
            execution_time=0.0,
            exit_code=1,
            syntax_valid=True
        )
    
    def validate_syntax(self, code_snippet: str, language: str = "python") -> bool:
        """
        Check if code has valid syntax without executing it.
        
        Args:
            code_snippet: The code to check
            language: Programming language of the code
            
        Returns:
            bool: True if syntax is valid, False otherwise
        """
        if language.lower() == "python":
            try:
                compile(code_snippet, '<string>', 'exec')
                return True
            except SyntaxError:
                return False
        
        return False  # Unsupported language
    
    def _execute_python(self, code_snippet: str) -> ExecutionResult:
        """
        Execute Python code in a secure environment.
        
        Args:
            code_snippet: Python code to execute
            
        Returns:
            ExecutionResult: Results of the execution
        """
        # Create a temporary file for the code
        with tempfile.NamedTemporaryFile(suffix='.py', delete=False) as temp_file:
            temp_file_path = temp_file.name
            temp_file.write(code_snippet.encode('utf-8'))
        
        start_time = time.time()
        
        try:
            # Execute the code in a subprocess with timeout
            process = subprocess.Popen(
                ['python', temp_file_path],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            try:
                stdout, stderr = process.communicate(timeout=self.timeout)
                exit_code = process.returncode
                success = exit_code == 0
            except subprocess.TimeoutExpired:
                # Kill the process if it times out
                process.kill()
                stdout, stderr = process.communicate()
                exit_code = -1
                success = False
                stderr = f"Execution timed out after {self.timeout} seconds"
        
        except Exception as e:
            success = False
            stdout = ""
            stderr = f"Execution error: {str(e)}"
            exit_code = 1
        
        finally:
            # Clean up the temporary file
            if os.path.exists(temp_file_path):
                os.unlink(temp_file_path)
        
        execution_time = time.time() - start_time
        
        return ExecutionResult(
            success=success,
            output=stdout,
            error=stderr,
            execution_time=execution_time,
            exit_code=exit_code,
            syntax_valid=True
        )
    
    def extract_function_from_response(self, response: str, function_name: str) -> Optional[str]:
        """
        Extract a function definition from an LLM response.
        
        Args:
            response: The full LLM response text
            function_name: Name of the function to extract
            
        Returns:
            str: Extracted function code or None if not found
        """
        # Look for Python code blocks
        code_block_pattern = r"```(?:python)?\s*(.*?)```"
        code_blocks = re.findall(code_block_pattern, response, re.DOTALL)
        
        if code_blocks:
            # Check each code block for the function
            for block in code_blocks:
                # Look for function definition
                function_pattern = rf"def\s+{function_name}\s*\("
                if re.search(function_pattern, block):
                    return block.strip()
        
        # If no code blocks with markdown, try to find the function directly
        function_pattern = rf"def\s+{function_name}\s*\(.*?\).*?:"
        match = re.search(function_pattern, response, re.DOTALL)
        
        if match:
            # Try to extract the complete function
            lines = response[match.start():].split('\n')
            function_lines = [lines[0]]
            indent = None
            
            for i in range(1, len(lines)):
                line = lines[i]
                
                # Determine indentation of first non-empty line
                if indent is None and line.strip():
                    indent_match = re.match(r'^(\s+)', line)
                    if indent_match:
                        indent = indent_match.group(1)
                    else:
                        break  # No indentation, end of function
                
                # Check if we're still in the function
                if indent and line.startswith(indent):
                    function_lines.append(line)
                elif line.strip() and not line.startswith(' '):
                    break  # No longer indented, end of function
                elif not line.strip():
                    function_lines.append(line)  # Keep empty lines
                else:
                    break  # End of function
            
            return '\n'.join(function_lines)
        
        return None


if __name__ == "__main__":
    # Example usage and testing
    executor = CodeExecutor(timeout=2)
    
    print("=== Code Executor Demo ===\n")
    
    # Test valid code
    valid_code = """
def hello_world():
    print("Hello, world!")

hello_world()
"""
    
    print("Testing valid code:")
    result = executor.execute_code(valid_code)
    print(f"Success: {result.success}")
    print(f"Output: {result.output}")
    print(f"Error: {result.error}")
    print(f"Execution time: {result.execution_time:.4f} seconds")
    print(f"Exit code: {result.exit_code}")
    print(f"Syntax valid: {result.syntax_valid}")
    
    print("\n" + "="*50 + "\n")
    
    # Test code with syntax error
    invalid_code = """
def broken_function()
    print("This has a syntax error")

broken_function()
"""
    
    print("Testing code with syntax error:")
    result = executor.execute_code(invalid_code)
    print(f"Success: {result.success}")
    print(f"Output: {result.output}")
    print(f"Error: {result.error}")
    print(f"Execution time: {result.execution_time:.4f} seconds")
    print(f"Exit code: {result.exit_code}")
    print(f"Syntax valid: {result.syntax_valid}")
    
    print("\n" + "="*50 + "\n")
    
    # Test code that times out
    timeout_code = """
import time

def infinite_loop():
    while True:
        pass

infinite_loop()
"""
    
    print("Testing code that times out:")
    result = executor.execute_code(timeout_code)
    print(f"Success: {result.success}")
    print(f"Output: {result.output}")
    print(f"Error: {result.error}")
    print(f"Execution time: {result.execution_time:.4f} seconds")
    print(f"Exit code: {result.exit_code}")
    print(f"Syntax valid: {result.syntax_valid}")